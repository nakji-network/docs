"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[251],{3905:function(e,n,t){t.d(n,{Zo:function(){return u},kt:function(){return f}});var r=t(7294);function o(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function a(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function i(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?a(Object(t),!0).forEach((function(n){o(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):a(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function c(e,n){if(null==e)return{};var t,r,o=function(e,n){if(null==e)return{};var t,r,o={},a=Object.keys(e);for(r=0;r<a.length;r++)t=a[r],n.indexOf(t)>=0||(o[t]=e[t]);return o}(e,n);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(r=0;r<a.length;r++)t=a[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(o[t]=e[t])}return o}var s=r.createContext({}),l=function(e){var n=r.useContext(s),t=n;return e&&(t="function"==typeof e?e(n):i(i({},n),e)),t},u=function(e){var n=l(e.components);return r.createElement(s.Provider,{value:n},e.children)},m={inlineCode:"code",wrapper:function(e){var n=e.children;return r.createElement(r.Fragment,{},n)}},p=r.forwardRef((function(e,n){var t=e.components,o=e.mdxType,a=e.originalType,s=e.parentName,u=c(e,["components","mdxType","originalType","parentName"]),p=l(t),f=o,h=p["".concat(s,".").concat(f)]||p[f]||m[f]||a;return t?r.createElement(h,i(i({ref:n},u),{},{components:t})):r.createElement(h,i({ref:n},u))}));function f(e,n){var t=arguments,o=n&&n.mdxType;if("string"==typeof e||o){var a=t.length,i=new Array(a);i[0]=p;var c={};for(var s in n)hasOwnProperty.call(n,s)&&(c[s]=n[s]);c.originalType=e,c.mdxType="string"==typeof e?e:o,i[1]=c;for(var l=2;l<a;l++)i[l]=t[l];return r.createElement.apply(null,i)}return r.createElement.apply(null,t)}p.displayName="MDXCreateElement"},3755:function(e,n,t){t.r(n),t.d(n,{frontMatter:function(){return c},contentTitle:function(){return s},metadata:function(){return l},toc:function(){return u},default:function(){return p}});var r=t(7462),o=t(3366),a=(t(7294),t(3905)),i=["components"],c={sidebar_position:3},s="Source Connector",l={unversionedId:"components/connectors/source-connector",id:"components/connectors/source-connector",title:"Source Connector",description:"There are only TWO requirements when it comes to writing a valid Nakji Network Source Connector:",source:"@site/docs/components/connectors/source-connector.md",sourceDirName:"components/connectors",slug:"/components/connectors/source-connector",permalink:"/docs/components/connectors/source-connector",tags:[],version:"current",sidebarPosition:3,frontMatter:{sidebar_position:3},sidebar:"tutorialSidebar",previous:{title:"Common Patterns",permalink:"/docs/components/connectors/common-patterns"},next:{title:"Auth",permalink:"/docs/reference/auth"}},u=[{value:"Example",id:"example",children:[{value:"Protobuf",id:"protobuf",children:[],level:3},{value:"Manifest",id:"manifest",children:[],level:3},{value:"Executable",id:"executable",children:[],level:3},{value:"Main connector code",id:"main-connector-code",children:[],level:3}],level:2},{value:"Advanced",id:"advanced",children:[],level:2},{value:"Support",id:"support",children:[],level:2}],m={toc:u};function p(e){var n=e.components,t=(0,o.Z)(e,i);return(0,a.kt)("wrapper",(0,r.Z)({},m,t,{components:n,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"source-connector"},"Source Connector"),(0,a.kt)("p",null,"There are ",(0,a.kt)("strong",{parentName:"p"},"only TWO requirements")," when it comes to writing a valid Nakji Network Source Connector:"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},"Write ",(0,a.kt)("a",{parentName:"li",href:"https://developers.google.com/protocol-buffers"},"protobuf")," messages to ",(0,a.kt)("a",{parentName:"li",href:"https://kafka.apache.org/"},"Nakji Message Queue (Kafka)")," using ",(0,a.kt)("a",{parentName:"li",href:"https://www.confluent.io/blog/transactions-apache-kafka/"},"transactions"),"."),(0,a.kt)("li",{parentName:"ol"},"Manifest file that contains connector metadata (eg title, author, version)")),(0,a.kt)("p",null,"There are no DSLs (domain specific languages) you have to learn, no weird structures you have to abide by, and no awkward terminology you have to remember."),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},(0,a.kt)("em",{parentName:"strong"},"Just Send Data."))),(0,a.kt)("h2",{id:"example"},"Example"),(0,a.kt)("p",null,"This is an example of a barebones Ethereum connector which ingests Block and Transaction data into Nakji, written in Golang."),(0,a.kt)("div",{className:"admonition admonition-info alert alert--info"},(0,a.kt)("div",{parentName:"div",className:"admonition-heading"},(0,a.kt)("h5",{parentName:"div"},(0,a.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,a.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},(0,a.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"}))),"info")),(0,a.kt)("div",{parentName:"div",className:"admonition-content"},(0,a.kt)("p",{parentName:"div"},"This example is currently 90% finished, with most key features present. Some of the libraries referenced in the Go files have not been published publicly yet. A fully functional source connector will be published in a public repo soon. "))),(0,a.kt)("h3",{id:"protobuf"},"Protobuf"),(0,a.kt)("p",null,"First, a ",(0,a.kt)("inlineCode",{parentName:"p"},"protobuf")," definition file needs to be created. Protobuf is the platform-neutral data format for almost all the ",(0,a.kt)("em",{parentName:"p"},"data in motion")," within Nakji, whether it's into or out of the Nakji Message Queue. Make sure to use Version 3 of the Protobuf spec (",(0,a.kt)("a",{parentName:"p",href:"https://developers.google.com/protocol-buffers/docs/proto3"},"proto3 documentation"),")."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-protobuf",metastring:'title="/ethereum.proto"',title:'"/ethereum.proto"'},'syntax = "proto3";\n\nimport "google/protobuf/timestamp.proto";\n\npackage ethereum;\n\noption go_package = "github.com/nakji-network/connector/examples/ethereum_connector";\n\n// to convert addresses from bytes to hex address, https://github.com/ethereum/go-ethereum/blob/4b2ff1457ac28fb2894485194e0e344e84c2bcd7/common/types.go#L210\nmessage Transaction {\n  google.protobuf.Timestamp Timestamp    = 1; //uint64\n  bytes                     From         = 2;\n  string                    Hash         = 3;\n  double                    Size         = 4;\n  uint64                    AccountNonce = 5; // uint64\n  uint64                    Price        = 6; // big.int\n  uint64                    GasLimit     = 7; // uint64\n  bytes                     Recipient    = 8;\n  uint64                    Amount       = 9; // big.int\n  bytes                     Payload      = 10;\n  uint64                    V            = 11; // big.int\n  uint64                    R            = 12; // big.int\n  uint64                    S            = 13; // big.int\n}\n\nmessage Block {\n  google.protobuf.Timestamp Timestamp  = 1; //uint64\n  string                    Hash       = 2;\n  uint64                    Difficulty = 3; //bigint\n  uint64                    Number     = 4; //bigint\n  uint64                    GasLimit   = 5; // uint64\n  uint64                    GasUsed    = 6; // uint64\n  uint64                    Nonce      = 7; //[8]byte .Uint64()\n}\n')),(0,a.kt)("p",null,"The proto definitions can be compiled by the ",(0,a.kt)("inlineCode",{parentName:"p"},"protoc")," compiler into any language it supports (currently 7) to enable seamless cross-platform/cross-service communication. For purposes of this example, follow the ",(0,a.kt)("a",{parentName:"p",href:"https://developers.google.com/protocol-buffers/docs/gotutorial"},"Protobuf for Golang guide here")," to get set up."),(0,a.kt)("h3",{id:"manifest"},"Manifest"),(0,a.kt)("p",null,"Create a file named ",(0,a.kt)("inlineCode",{parentName:"p"},"manifest.yaml")," in the project root with the following fields."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-yaml",metastring:'title="/manifest.yaml"',title:'"/manifest.yaml"'},'package: ethereum\nowner: allie\nversion: "0_0_0"\n')),(0,a.kt)("h3",{id:"executable"},"Executable"),(0,a.kt)("p",null,"The ",(0,a.kt)("inlineCode",{parentName:"p"},"cmd/ethereum/main.go")," file prepares all the config variables and Kafka connections."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go",metastring:'title="/cmd/ethereum/main.go"',title:'"/cmd/ethereum/main.go"'},'// This connector ingests real time data from any EVM compatible chain.\npackage main\n\nimport (\n    "fmt"\n\n    "github.com/nakji-network/connector/config"\n    "github.com/nakji-network/connector/examples/ethereum"\n    . "github.com/nakji-network/connector/kafkautils"\n    "github.com/nakji-network/connector/monitor"\n    "github.com/nakji-network/connector/manifest"\n    "github.com/rs/zerolog/log"\n)\n\nvar conf = config.GetConfig()\n\nfunc init() {\n    //conf.SetDefault("rpcs.ethereum.full", []string{"wss://mainnet.infura.io/ws/v3/"})\n}\n\nfunc main() {\n    // Load manifest file and config variables\n    m := manifest.Load()\n    RPCURLs := conf.GetStringSlice("rpcs.ethereum.full")\n\n    log.Info().\n        Strs("RPCs", RPCURLs).\n        Str("kafkaTxId", kafkaTransactionID).\n        Msg("Starting EVM connector")\n\n    // Initialize Kakfa Producer\n    kp, err := NewProducer(conf.GetString("kafka.url"), m)\n    if err != nil {\n        log.Fatal().Err(err).Msg("Failed to create new kafka producer")\n    }\n\n    connector := ethereum.EthereumConnector{\n        KP:       kp,\n        RPCURLs:  RPCURLs,\n        Manifest: m,\n    }\n\n    connector.Start()\n}\n')),(0,a.kt)("h3",{id:"main-connector-code"},"Main connector code"),(0,a.kt)("p",null,"The ",(0,a.kt)("inlineCode",{parentName:"p"},"ethereum.go")," file connects to the data source (in this case, an Ethereum RPC). When data is received, it is cleaned and shaped into the Protobuf format defined above, and sent to the correct Topics in the Nakji Message Queue (Kafka)."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go",metastring:'title="/ethereum.go"',title:'"/ethereum.go"'},'package ethereum\n\nimport (\n    "context"\n    "fmt"\n    "os"\n    "os/signal"\n\n    "github.com/ethereum/go-ethereum/core/types"\n    ethtypes "github.com/ethereum/go-ethereum/core/types"\n    "github.com/ethereum/go-ethereum/ethclient"\n    "github.com/nakji-network/connector/manifest"\n    "github.com/rs/zerolog/log"\n\n    . "github.com/nakji-network/connector/kafkautils"\n)\n\ntype EthereumConnector struct {\n    KP       *Producer\n    RPCURLs  []string\n    Manifest manifest.Manifest\n}\n\nfunc (c EthereumConnector) Start() {\n    interrupt := make(chan os.Signal, 1)\n    signal.Notify(interrupt, os.Interrupt)\n\n    // connect to Ethereum RPC websockets\n    log.Info().Strs("url", c.RPCURLs).Msg("connecting to Ethereum RPC")\n    client, err := ethclient.DialContext(context.Background(), c.RPCURLs)\n    if err != nil {\n        log.Fatal().Err(err).Msg("Ethereum RPC connection error")\n    }\n\n    // Subscribe to headers\n  headers := make(chan *types.Header)\n    sub, err := client.SubscribeNewHead(context.Background(), headers)\n    if err != nil {\n        log.Fatal().Err(err)\n    }\n\n    // kafkaKey examples: namespace.subject, eth.eth, arbitrum.arbitrum\n    kafkaKey := []byte("eth.eth")\n\n    defer client.Close()\n\n    // Start kafka transactions\n    c.KP.EnableTransactions()\n\n    go func() {\n        for {\n            select {\n            case err := <-sub.Err():\n                log.Fatal(err)\n\n            // Loop through this whenever a new header is received\n            case header := <-headers:\n                // Header doesn\'t contain all the block data so we have to call `BlockByHash` to retrieve it\n                block, err := client.BlockByHash(context.Background(), header.Hash())\n                if err != nil {\n                    log.Fatal(err)\n                }\n\n                PrintBlock(block)\n\n                // Convert Geth.Block -> Block generated by protoc -> Protobuf -> kafka\n                var blockData Block\n                blockData.UnmarshalEthBlock(block) // defined elsewhere\n                err = c.KP.WriteKafkaMessages(c.Manifest.Topic("block"), kafkaKey, &blockData)\n                if err != nil {\n                    log.Error().Err(err).Msg("Kafka write proto")\n                }\n\n                // Convert Geth.Transaction -> Transaction generated by protoc -> Protobuf -> Kafka\n                for _, tx := range block.Transactions() {\n                    txData := Transaction{}\n                    txData.UnmarshalEthTransaction(tx)\n                    txData.Timestamp = blockData.Timestamp // Timestamp isn\'t in the raw transaction from geth\n\n                    err := c.KP.WriteKafkaMessages(c.Manifest.Topic("tx"), kafkaKey, &txData)\n                    if err != nil {\n                        log.Error().Err(err).Msg("Kafka write proto")\n                    }\n                }\n\n                // Commit Kafka Transaction\n                err = c.KP.CommitTransaction(nil)\n                if err != nil {\n                    log.Error().Err(err).Msg("Processor: Failed to commit transaction")\n\n                    err = c.KP.AbortTransaction(nil)\n                    if err != nil {\n                        log.Fatal().Err(err).Msg("")\n                    }\n                }\n                // Start a new transaction\n                err = c.KP.BeginTransaction()\n                if err != nil {\n                    log.Fatal().Err(err).Msg("")\n                }\n\n            }\n        }\n    }()\n\n    for {\n        select {\n        case <-interrupt:\n            log.Debug().Msg("interrupt")\n\n            // Cleanly close the connection by sending a close message and then\n            // waiting (with timeout) for the server to close the connection.\n            client.Close()\n            c.KP.Close()\n            return\n        }\n    }\n}\n\nfunc PrintBlock(block *ethtypes.Block) {\n    fmt.Printf("hash: %s\\n", block.Hash().Hex())       // 0xbc10defa8dda384c96a17640d84de5578804945d347072e091b4e5f390ddea7f\n    fmt.Printf("num: %v\\n", block.Number().Uint64())   // 3477413\n    fmt.Printf("time: %v\\n", block.Time())             // 1529525947\n    fmt.Printf("nonce: %v\\n", block.Nonce())           // 130524141876765836\n    fmt.Printf("#tx: %v\\n", len(block.Transactions())) // 7\n    fmt.Printf("gaslim: %v\\n", block.GasLimit())       // 1529525947\n    fmt.Printf("gasuse: %v\\n", block.GasUsed())        // 1529525947\n    fmt.Printf("diff: %v\\n", block.Difficulty())       // 1529525947\n}\n')),(0,a.kt)("h2",{id:"advanced"},"Advanced"),(0,a.kt)("p",null,"In some cases, a source connector may use input data from the Nakji message queue instead of an external source. This reduces the need for every connector to make a new RPC request, at the cost of slightly increasing latency. For example:"),(0,a.kt)("p",null,(0,a.kt)("img",{parentName:"p",src:"/img/kroki/47cc7e8b4a4ba447afff0e10d5cf51b7.svg",alt:"47cc7e8b4a4ba447afff0e10d5cf51b7",title:"Aggregator connectors"})),(0,a.kt)("p",null,"This is a rare use case."),(0,a.kt)("h2",{id:"support"},"Support"),(0,a.kt)("p",null,"Feel free to reach out to the team if you run into issues or need assistance!"))}p.isMDXComponent=!0}}]);